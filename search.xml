<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于数据库设计知识的复习]]></title>
    <url>%2Farchives%2Fc2a53119.html</url>
    <content type="text"><![CDATA[需求分析阶段1. 数据库设计简介1.1 什么是数据库设计？简单来说，数据库设计就是根据业务系统的具体需要，结合我们所选用的DBMS（数据库管理系统），为这个业务体系构造出最优的数据存储模型，并建立好数据库中的表结构以及表与表之间的关联关系的过程，使其能够有效的对应用系统中的数据进行存储，并可以高效的对已经存储的数据进行访问。 1.2 为什么要进行数据库的设计？ 优良的设计 糟糕的设计 减少数据冗余 存在大量的数据冗余 避免数据维护异常 存在数据插入、更新、删除异常 节约存储空间 浪费大量存储空间 高效的访问 访问数据低效 在数据库最初使用是，由于数据量较小，可能看不出数良好的数据库设计的必要。但当业务越来越多，越来越复杂，数据量不断增长时，糟糕的数据库设计便阻碍了公司正常业务的进行，而且对开发人员会造成很大的影响。所以，在系统设计开始就对数据库进行良好的设计是非常有必要的。 2. 数据库设计的步骤数据库设计的步骤主要分为以下四个阶段： 2.1 需求分析数据库设计的需求分析与应用程序的需求分析不同，这里它的主要作用点是： 数据是什么 数据有哪些属性 数据和属性各自的特点有哪些 2.2 逻辑设计主要使用ER图对数据库进行逻辑建模 2.3 物理设计根据数据库自身的特点把逻辑设计转化为物理设计，即用不同的DBMS建立相应的数据库和数据表等。 2.4 维护优化为保持数据库高效而稳定，在本阶段中主要做的工作如下： 根据新的需求进行建表 索引拆分 大表拆分（水平拆分和垂直拆分） 3. 需求分析的重要性3.1 为什么要进行需求分析 了解系统中所要存储的数据 了解数据的存储特点 了解数据的生命周期 通过进行需求分析，对于我们构建表的过程中具有非常重要的作用，更影响到了后期开发的难度。 3.2 要搞清楚的问题 实体和实体之间的关系（一对一，一对多，多对多） 实体包含的属性有什么 哪些属性或属性的组合可以唯一标识一个实体 逻辑设计阶段1. 逻辑设计简介1.1 逻辑设计用来做什么 见需求转化为数据库的逻辑模型 通过ER图的形式对逻辑模型进行展示 与将来选用的具体DBMS系统无关 1.2 名词解释 关系：一个关心对应通常诉说的一张表 元组：表中的一行即为一个元组 属性：表中的一列即为一个属性；每个属性都有一个名称，成为属性名 候选码：表中的某个属性组，它可以唯一确定一个元组 主码：一个关系有多个候选码，选定某一个作为主码，也称主键 域：属性的取值范围 分量：元组中的一个属性值 1.3 ER图例说明 矩形：表示实体集，矩形内部写实体集名字 菱形：表示联系集 椭圆：表示实体的属性（属性名加下划线表示主键） 线段：将属性连接到实体集，或将联系集连接到实体集 2. 设计范式概要在进行数据库设计的时候，我们会碰到建立表的问题，例如： 用户信息和购物车信息 =&gt; 一张表 或 用户信息 =&gt; 一张表 购物车信息 =&gt; 一张表 到底应该怎样设计比较好呢？这里就引出了数据库设计范式的问题。 2.1 什么是数据库设计范式常见的数据库设计范式包括： 第一范式，第二范式，第三范式以及BC范式 还有第四范式以及第五范式，不过我们重点是在前三个范式上，也是大多数数据库设计索要遵循的范式。 2.2 数据操作异常以及数据冗余范式通常就是为了解决数据操作异常以及数据冗余而存在的，数据操作异常主要指以下三类： 插入异常：如果某实体随着另一个实体的存在而存在，即缺少某个实体时无法表示这个实体，那么这个表就存在插入异常 更新异常：如果更改表所对应的某个实体实例的单独属性时，需要将多行更新，那么这个表就存在更新异常 删除异常：如果删除表的某一行来反应某实体实例失效时导致另一个不同实体实例信息丢失，那么这个表就存在删除异常 注：一般一个表存在插入异常的同时，必定存在着更新异常和删除异常！ 数据冗余是指相同的数据在多个地方存在，或者说表中的某个列可以由其他列计算得到。数据冗余会产生许多无用的不必要的数据，给数据库表带来更大的压力，不利于以后的开发和维护。一般设计时应避免出现数据冗余。 2.3 第一范式（1NF）定义：数据库表中的所有字段都是单一属性，不可再分的。这个单一属性是由基本的数据类型所构成的，如整数，浮点数，字符串等。换句话说，第一范式要求数据库中的表都是二维表。 2.4 第二范式（2NF）定义：数据库中的表中不存在非关键字段对任一候选关键字段的部分函数依赖。部分函数依赖是指存在着组合关键字中的某一关键字决定非关键字的情况。换句话说，所有单关键字段的表都符合第二范式。 举个栗子： 商品名称 供应商名称 价格 描述 重量 供应商电话 有效期 分类 可乐 饮料一厂 3.00 500ml 1234567 2019.01 饮料 可乐 饮料二厂 3.00 500ml 7654321 2019.01 饮料 上表中由于供应商和商品之间是多对多的关系，所以只有使用商品名称和供应商名称组合才可以唯一标识出一件商品，换句话说，主键应为：（商品名称+供应商名称）。这里，表中存在着以下部分函数依赖： （商品名称）决定（价格，描述，重量，有效期） （供应商名称）决定（供应商电话） 这违反了第二范式的规则，所以存在着数据操作异常以及数据冗余。一个正确的修改例子如下：（将原来的一张表拆分） 商品ID 商品名称 价格 描述 重量 有效期 分类 1 可乐 3.00 500ml 2019.01 饮料 供应商ID 供应商名称 供应商电话 1 饮料一厂 1234567 2 饮料二厂 7654321 2.5 第三范式（3NF）定义：第三范式是在第二范式的基础之上定义的，如果数据表中不存在非关键字段对任意候选关键字段的传递函数依赖，则符合第三范式。举个栗子： 商品名称 价格 商品描述 重量 有效期 分类 分类描述 可乐 3.00 500ml 2019.01 酒水饮料 碳酸饮料 苹果 5.00 500g 生鲜食品 水果 上述表中存在着以下传递函数依赖关系： （商品名称）决定（分类）决定（分类描述） 也就是说，存在非关键字段“分类描述”对关键字段“商品名称”的传递函数依赖。 这里，（分类，分类描述）对于每一个商品都会进行记录，存在着数据冗余，同时还存在着数据操作异常。一个正确的修改例子如下：（拆分表） 商品ID 商品名称 价格 商品描述 重量 有效期 1 可乐 3.00 500ml 2019.01 分类ID 分类 分类描述 1 酒水饮料 碳酸饮料 2.6 BC范式（BCNF）定义：在第三范式的基础之上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BC范式。也就是说，如果是复合关键字，则复合关键字之间也不能存在函数依赖关系。 举个栗子： 供应商 商品ID 供应商联系人 商品数量 饮料一厂 1 张三 10 饮料二厂 2 李四 20 饮料二厂 1 王五 20 这里我们假定，供应商联系人只能受雇于一家供应商，没加供应商可以供应多个商品。则存在着如下决定关系： （供应商，商品ID）决定（联系人，商品数量） （联系人，商品ID）决定（供应商，商品数量） 而由于下列关系的存在，则不符合BC范式的要求： （供应商）决定（供应商联系人） （供应商联系人）决定（供应商） 一种正确的修改方式如下：（拆分） 供应商 商品ID 商品数量 饮料一厂 1 10 饮料一厂 2 20 饮料二厂 1 20 供应商 供应商联系人 饮料一厂 张三 饮料一厂 李四 饮料二厂 王五 物理设计阶段1. 物理设计简介物理设计就是将逻辑设计转化为真正使用DBMS创建和管理数据库数据表的过程，在这个过程中同样存在着许多设计上的选择和问题。那么物理设计要做什么？ 选择合适的数据库管理系统 定义数据库、表以及字段的命名规范 根据所选的DBMS系统选择合适的字段类型 反范式化的设计 2. 选择合适的数据库管理系统（DBMS）这里暂时不探讨NoSql数据库，只对传统关系型数据库进行一点简单的区分选择。以下是常见的关系型数据库 Oracle：属于商业数据库，在使用时不得不考虑版权问题。在业界中口碑较好，性能高，比较适合大型事务操作，因为在Oracle数据库中事务操作成本较低。可以运行在Windows、类Unix操作系统上，使用Java、PHP等语言较为适合 SQLServer：属于商业数据库，版权问题需考虑。事务操作成本较高，比较适合小型事务操作。由于是微软开发的，它只支持运行在Windows操作系统，并且与 .Net 语言契合度较高。 MySQL：开源数据库，只要符合社区协议，使用时不用支付任何费用。像SQLServer一样，事务操作成本较高，也是比较适合小型事务操作。可运行在Windows、类Unix操作系统上，同样适合Java、PHP等编程语言。 总体来说，Oracle、SQLServer数据库适合于大型企业级项目，而MySQL数据库更适合于互联网项目。 3. MySQL 常用的存储引擎 存储引擎 事务 颗粒度 主要应用 忌用 MyISAM 不支持 支持并发插入的表级锁 SELECT，INSERT 读写操作频繁 MRG_MYISAM 不支持 支持并发插入的表级锁 分段归档，数据仓库 全局查找过多的场景 Innodb 支持 支持MVCC的行级锁 事务处理 无 Archive 不支持 行级锁 日志记录，只支持INSERT，SELECT 需要随机读取，更新，删除 Ndb cluster 支持 行级锁 高可用性 大部分应用 目前，我们常用的是 Innodb 引擎。 4. 表及字段的命名规则所有对象命名应该遵循以下原则： 可读性原则：使用大写和小写来格式化的库对象名字，以获得良好的可读性。例如：使用UserAddress而不是useraddress来提高可读性（注意，有些DBMS系统对表名的大小写是敏感的） 表意性原则：对象的名字应该能够描述它所标识的对象。例如：对于表，表的名称应该能够体现表中存储的数据内容；对于存储过程，存储过程名称应该能够体现存储过程的功能。 长名原则：尽可能少使用或者不使用缩写，适用于数据库（DATABASE）名之外的任一对象 5. 字段类型的选择原则列的数据类型一方面影响数据存储空间的开销，另一方面也会影响到数据查询性能。当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。 以下是 MySQL 中每种数据类型占用空间大小的对比： 列类型 存储空间 TINYINT 1 字节 SMALLINT 2 字节 MEDIUMINT 3 字节 INT 4 字节 BIGINT 8 字节 DATE 3 字节 DATETIME 8 字节 TIMESTAMP 4 字节 CHAR（M） M 字节，1 &lt;= M &lt;= 255 VARCHAR（M） L + 1 字节，L &lt;= M 且 1 &lt;= M &lt;= 255 以上选择原则主要是从下面两个角度考虑的： 在对数据进行比较（查询条件，JOIN条件以及排序）操作时，同样的数据，字符处理往往比数字处理慢。 在数据库中，数据处理以页为单位，列的长度越小，每页存储量越多，性能也就越好。 6. 字段类型的具体选择6.1 char 与 varchar 如果列中要存储的数据长度差不多是一致的，则考虑用 char，否则考虑用 varchar。 如果列中的最大数据长度小于 50 Byte， 则一般考虑用 char。（如果此列很少使用，出于节省空间和减少 I/O 的考虑，还是可以选择使用 varchar） 一般不宜定义大于 50 Byte 的 char 类型列。 6.2 decimal 与 float decimal 用于存储精确数据，而 float 只能用于存储非精确数据。 由于 float 占用存储空间一般比 decimal 小，所以非精确数据优先选择 float 类型。 6.3 时间类型的存储 使用 INT 来存储时间字段（一般用于很少查询的情况） 优点：字段长度比 DATETIME 小 缺点：使用不方便，要进行函数转换才能获得具体表示的时间 限制：只能存储到 2038-01-19 11:14:07，即 2^32 为 2147483648 根据需要存储的时间粒度来选择存储类型 年，月，日，周，时，分，秒 7. 其他注意事项7.1 如何选择主键 区分业务主键和数据库主键 业务主键用于标识业务数据，进行表与表之间的关联； 数据库主键为了优化数据存储（Innodb 会生成6个字节的隐含主键） 根据数据库的类型，考虑主键是否要顺序增长 有些数据库是按主键的顺序逻辑存储的 主键的字段类型所占空间要尽可能的小 对于使用聚集索引方式存储的表，每个索引后都会附加主键信息。 7.2 避免使用外键约束 降低数据导入的效率 增加维护成本 虽然不建议使用外键约束，但是相关联的列上一定要建立索引 7.3 避免使用触发器 降低数据导入的效率 可能会出现意想不到的数据异常 使业务逻辑变得更加复杂 7.4 关于预留字段 无法准确的知道预留字段的类型 无法准确的知道预留字段中所存储的内容 后期维护预留字段所需要的成本，和增加一个字段所需要的成本是相同的 严禁使用预留字段 8. 反范式化表设计什么是反范式化？反范式化是针对范式化而言的，它就是为了性能和读取效率的考虑而适当的对第三范式的要求进行违反，而允许存在少量的数据冗余。换句话说，反范式化就是使用空间来换取时间。 举个栗子： 以下是一个符合范式化的设计数据库表结构： 1234用户表： 用户ID 姓名 电话 地址 邮编订单表： 订单ID 用户ID 下单时间 支付类型 订单状态订单商品表： 订单ID 商品ID 商品数量 商品价格商品表： 商品ID 名称 描述 过期时间 对于上述设计，查询订单详情语句如下： 12345SELECT b.用户名, b.电话, b.地址, a.订单ID, SUM(c.商品价格*c.商品数量) as 订单价格, c.商品价格 \ FROM &quot;订单表&quot; a \ JOIN &quot;用户表&quot; b ON a.用户ID = b.用户ID \ JOIN &quot;订单商品表&quot; c ON c.订单ID = b.订单ID \ JOIN &quot;商品表&quot; d on d.商品ID = c.商品ID 而对于一个反范式化设计如下： 1234用户表： 用户ID 姓名 电话 地址 邮编订单表： 订单ID 用户ID 下单时间 支付类型 订单状态 订单价格 姓名 地址 电话订单商品表： 订单ID 商品ID 商品数量 商品价格 商品名称 过期时间商品表： 商品ID 名称 描述 过期时间 此时，当我们想要查询订单详情时，查询语句将会变得非常简单： 1SELECT a.用户名, a.电话, a.地址, a.订单ID, a.订单价格 FROM &quot;订单表&quot; a 由此可见，当我们读写比例比较大时，即读取数据次数比起写入次数总是要多很多时，使用反范式化构建表还是非常有必要的，这样可以加快我们的查询效率。 总结起来，反范式化的原因主要有以下几点： 减少表的关联数量 增加数据的读取效率 注意：反范式化一定要适度，不然可能造成数据的操作异常，得不偿失。 维护优化阶段随着业务的增长，需求在不断的变化，此时对于数据库的维护和优化就显得尤为重要。在这个阶段中，我们主要做的事情有以下几方面： 维护数据字典 维护索引 维护表结构 在适当的时候对表进行水平拆分或垂直拆分 1. 维护数据字典维护数据字典的方式主要有以下几种： 使用第三方工具对数据字典进行维护 利用数据库本身的备注字段来维护数据字典 如使用 MySQL 中的 COMMENT 关键字 导出数据字典 2. 维护索引索引的选择一般有以下几种： 出现在 WHERE 从句，GROUP BY 从句或是 ORDER BY 从句中的列 可选择性高的列要放在索引前面 索引中不要包括太长的数据类型 注意： 索引并不是越多越好，过多的索引不但会降低写效率，而且会降低读的效率 要定期维护索引碎片 在 SQL 语句中，不要使用强制索引关键字 3. 维护表结构3.1 常用的维护表结构的方法如下： 使用在线变更表结构的工具 在 MySQL 5.5 之前可以使用 pt-online-schema-change 来处理（此时涉及到之前提过的避免使用触发器，因为有的第三方工具在运行过程中，是会给数据库添加一些触发器来支持它们的操作，如果自己之前设置过触发器，很可能会损坏数据。） 在 MySQL 5.6 之后，数据库本身支持了在线表结构的变更 同时对数据字典进行维护 表结构更变的同时，一定要记得相应的更变数据字典 控制表的宽度和大小 3.2 数据库中适合的操作 批量操作 vs 逐条操作 显然，数据库适合批量操作，逐条操作适合在程序中完成 禁止使用 SELECT * 这样的语句 会造成 IO 的浪费，同时，如果表结构变更，可能会对程序造成影响 控制使用用户自定义函数 大量使用自定义函数会对索引产生不好的影响，自定义函数往往比较低效 不要使用数据库中的全文索引 需要这种功能，最好使用搜索引擎代替全文索引，提升效率 4. 数据表的拆分当数据表的结构变化，如表越来越宽，或表越来越长，我们应该分别使用垂直拆分和水平拆分来控制表的大小和宽度，以保证数据库执行的效率 4.1 表的垂直拆分通常以如下方法进行垂直拆分： 经常一起查询的列放到一起 这样不需要进行 JOIN 操作，减少了 I/O，同时还简化了查询语句 text, bolb 等大字段拆分出到附加表中 4.2 表的水平拆分一般采用 hash 的方法，将一张很大的表拆分为几个拥有相同属性的小表 4.3 两种拆分方式总结垂直拆分解决了表的宽度问题，水平拆分解决了表的数据量大小问题。两种拆分都可以优化数据库表的 I/O，进而提升了数据库的效率。 参考慕课网 - 数据库设计那些事]]></content>
      <categories>
        <category>学习与总结</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中volatile关键字]]></title>
    <url>%2Farchives%2F34ac48e.html</url>
    <content type="text"><![CDATA[简介在Java内存模型中，有主内存和每个线程各自的工作内存。为了提高运行性能，一个线程会在自己的内存中拷贝一份成员变量的副本。而工作内存在线程之间是互相隔离的，彼此对其他线程不可见。线程对变量的所有操作都必须在工作内存中进行，修改结束后，变量副本需写会主内存。这样的内存机制变回导致同一个变量在某个时间点，在一个线程的内存中的值（如B）与另一个线程的内存中的值（如C），或是与主内存中的值（如A）不一致的情况。而volatile关键字正是为了避免这种情况，它会告诉JVM（Java虚拟机），被volatile修饰的变量不在其他线程的内存中保留拷贝，而是直接访问主内存的变量。 volatile关键字用法当一个变量声明为volatile时，就意味着这个变量被修改时其他所有使用到此变量的线程都立即能见到变化（称之为可见性），并可随时被其他线程修改。具体是在每次使用前都要先刷新，以保证别的线程中的修改已经反映到本线程工作内存中，因此可以保证执行时的一致性。举个栗子：12345678910111213public class StoppableTask extends Thread &#123; private volatile boolean pleaseStop; public void run() &#123; while (!pleaseStop) &#123; // do some stuff... &#125; &#125; public void tellMeToStop() &#123; pleaseStop = true; &#125; &#125; 假如pleaseStop变量没有用volatile声明，那么在线程执行run的时候检查的就是自己的变量副本，如果其他线程已经调用了tellMeToStop()方法修改了pleaseStop的值，当前线程就无法及时得知此消息。 volatile和sychronizedVolatile一般情况下不能代替sychronized，因为volatile不能保证操作的原子性！这里要注意，i++这样的操作并不是原子性的，它实际上也是由多个原子操作组成的。假如多个线程同时执行i++，volatile只能保证他们操作的i变量是同一块内存，但依然可能出现写入脏数据的情况。 Volatile是变量修饰符，而synchronized作用于一段代码或方法。举个栗子： 12345678910111213141516int i1;int geti1() &#123; return i1;&#125;volatile int i2;int geti2() &#123; return i2;&#125;int i3;synchronized int geti3() &#123; return i3;&#125;geti1() 在上面的代码中，3个get()方法都是用来取得当前线程中对于变量的值。对于geti1()方法，多个线程中有着多个i1变量的拷贝，并且这些值可以互不相同。因此有如下可能性：主内存中 i1 = 0，线程1中 i1 = 1，线程2中 i1 = 2……这里线程1和线程2中都改变了它们各自的i1的值，而这个改变还未及时传递给主内存和其他线程，就导致了这种情况的发生。 对于geti2()方法，无论哪个线程去调用，得到的都是主内存中的i2的值。因为i2是被volatile修饰的，它在所有线程中必须是同步的，任何线程改变了它的值的同时，其他线程便立即获得了相同的值。注意：volatile修饰的变量存取时比一般变量消耗的资源要多一点，因为线程有它自己的变量拷贝更为高效。 既然volatile关键字已经实现了线程间数据同步，为什么我们还要用synchronized呢？一方面，synchronized会获得并释放监视器。话句话说，如果两个线程使用了同一个对象锁，监视器能强制保证被synchronized修饰的代码块或方法同时只被一个线程所执行。另一方面，synchronized也同步内存。它在“主内存区域同步整个线程的内存。因此，上述geti3()方法在执行时做了如下几步： 线程请求获得监视this对象的对象锁（假设此时还未被锁，否则线程将等待直到锁释放后获得） 线程内存的数据被消除，从主内存区域中读入 代码块被执行 对于变量的任何改变现在可以安全地写到主内存区域中（上述代码中geti3()方法并没有修改变量值） 线程释放监视this对象的对象锁 总结一下就是：volatile关键字只是在线程内存和主内存间同步某个变量的值，而synchronized通过加锁和解锁，保证代码块被执行的安全，并同步所有变量的值。所以synchronized要比volatile消耗更多资源。 volatile与变量类型在Java中，volatile关键字一般用于声明简单类型变量，比如int、float、 boolean等数据类型。如果这些简单数据类型声明为volatile，对它们的操作就会成为原子性操作。但这也有一定的限制（如之前提到的i++操作），举个栗子： 1234567891011121314151617181920212223242526272829public class MyThread extends Thread &#123; public volatile int n = 0; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; n = n + 1; sleep(2); &#125; catch (Exception e) &#123; System.out.println("Some exceptions..."); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Thread threads[] = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new MyThread(); // 创建100个线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); // 运行刚刚的线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].join(); // 100个线程都执行完后继续 &#125; System.out.println("n = " + MyThread.n); &#125;&#125; 如果上述代码对变量n的操作是原子性的，那么最后输出的结果应该为 n = 1000。但是在执行上面积代码时，很多时侯输出的n都小于1000，这说明 n = n + 1 操作不是原子性的！原因是，如果声明为volatile的简单变量的当前值和该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作： n++; n = n + 1; 如果要想使这种情况成为原子性操作，就需要使用synchronized关键字。上述的代码可以改成如下的形式： 123456789101112131415161718192021222324252627282930313233public class MyThread extends Thread &#123; public volatile int n = 0; public static synchronized void addOne() &#123; n++; // 或 n = n + 1; &#125; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; addOne(); sleep(2); &#125; catch (Exception e) &#123; System.out.println("Some exceptions..."); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Thread threads[] = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new MyThread(); // 创建100个线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); // 运行刚刚的线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].join(); // 100个线程都执行完后继续 &#125; System.out.println("n = " + MyThread.n); &#125;&#125; 上面的代码将简单的 n = n + 1 操作抽象成了 addOne() 方法，并使用synchronized关键字修饰，这时线程对于 n = n + 1 的操作便成为了原子性的。 在使用volatile关键字时一定要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作就都成为了原子性操作而保证线程安全，当变量的值受自身之前的值影响时，如 n = n + 1、n++ 等，volatile关键字便会失效；只有当变量的值和自身上一个值无关时，该变量的操作才是原子性的，如 n = m + 1 这个操作就是原子性的。 其他Volatile的另外一个作用是禁止指令的重排序优化。在一般情况下，Java执行语句的顺序可能会因为自动优化而修改，例如下面的例子，initialized的赋值有可能执行在doInitialize()语句之前，从而导致其他线程可能不会正确的等待初始化完成。 boolean initialized = false; 123// run in one threaddoInitialize();initialized = true; 1234// run in another threadwhile (!initialized) &#123; sleep();&#125; 如果将initialized变量用volatile关键字修饰，就能保证它的执行顺序不会被改变（似乎 Java SE 5之前的版本依然会有问题） ReferenceJava的volatile关键字的作用 Java中关键字volatile的作用]]></content>
      <categories>
        <category>学习与总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Hexo与GitHub搭建个人博客]]></title>
    <url>%2Farchives%2Ff23eadd3.html</url>
    <content type="text"><![CDATA[写在前面的废话很久以前就看到过许多漂亮的博客，尤其是在遇到技术问题百度一下的时候，总会点到一些技术大牛的个人博客里，看他们的解决方法和一些私人日志（偷笑）。每次看到漂亮的博客都觉的好羡慕，想着将来自己也搞这么个东西玩玩，于是就有了这个学来的“教程”。 了解 Hexo 和 GitHub 的朋友们，估计这篇小短文对你们也没什么帮助了，可以不用浪费时间啦~而对于普通小白，想要免费搭建一个可以让任何人都可以访问到的自己专属博客，可以继续往下看~ PS: 本教程以Mac OS作为参考，不同系统（Windows, Linux）具体安装工具方式可能不同，建议参考相关官网进行安装配置。 工具介绍HexoHexo （GitHub地址）是一个基于 Node.js 的静态博客程序，可以方便的生成静态网页托管在 Github 和 Heroku上。作者是来自台湾的@tommy351。官方介绍：12A fast, simple &amp; powerful blog framework, powered by Node.js.基于 Node.js 的快速、简洁但功能强大的博客框架。 Node.js使用 Hexo 需要依赖于 Node.js，在此做简单介绍，引用百度百科内容：123Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台，用来方便地搭建快速的易于扩展的网络应用.Node.js 借助事件驱动，非阻塞 I/O 模型变得轻量和高效， 非常适合运行在分布式设备的数据密集型的实时应用.Node.js 对 Google V8 引擎(应用于 Google Chrome 浏览器)进行了封装. Github我们用 Hexo 搭建好的博客要将网站托管在 Github 上，在此也简单介绍下。引自百度百科：123gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 准备工作安装 Node.jsNode.js 可以从官网根据不同系统下载安装。这里 Mac OS 推荐使用 Homebrew进行安装，省去了配置环境等麻烦，也易于卸载。直接在终端输入命令：1ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 安装 node.js，在终端输入：1sudo brew install node 此时可能需要输入电脑密码，输入完成后等待安装完成。再输入：1node -v 如果可以看到版本号，说明安装成功。 安装 Hexo安装 Hexo 极其简单，官网也只有一条命令：1npm install hexo-cli -g 等待安装完成，输入1hexo --versio 看到版本号说明安装成功。 安装 git同样的，git 也可以从官网下载安装，或者用 homebrew1brew install git 直接安装。（不过 Mac OS 好像是自带git的吧，或者只要安装了 xcode，git 就会自动安装）测试安装是否成功，在终端输入： 1git --version 看到版本号说明安装成功。 搭建博客准备工作完成，终于可以开始搭建我们自己的博客了。其实跟着Hexo官网的教程很快就可以自己搞定，但是如果懒得去可以继续往下看。 注意：以下所有的操作都在终端进行 选择路径 用 “cd” 命令进入想要建立博客的路径（文件夹）1cd 文件夹名称 初始化博客 比如我们建立的博客名字叫 blog，则终端输入命令：1hexo init blog 切换到刚刚的 blog 目录下，安装所有的依赖包：12cd blognpm install 到此，博客就算成功建立起来了，我们已经可以启动博客看看效果了。 启动博客 运行以下命令进行清理1hexo clean 运行以下命令生成所需要的静态页面及文件（g 即 generate）1hexo g 运行以下命令启动服务器（s 即 server）1hexo s 然后打开浏览器，输入地址 localhost:4000 即可看到效果 发表文章 比如我们想发表一篇名为“我的第一篇博客”的文章，在终端输入：1hexo new 我的第一篇博客 运行之后可以在 source/_posts 目录下生成“我的第一篇博客.md”文件，进入便可用 MarkDown 语言编写博客。 再利用上面三个命令重新生成下，看看效果123hexo cleanhexo ghexo s 配置博客 网站的设置大部分都在 _config.yml 文件中，详细配置可以查看官方文档，下面列出一些简单的常用配置： title -&gt; 网站标题subtitle -&gt; 网站副标题description -&gt; 网站描述author -&gt; 作者名字language -&gt; 网站使用的语言theme -&gt; 网站主题 注意：进行配置时，要在冒号后面加一个英文空格！ 关于主题和其他配置 同样的，许多好看的主题都在官网查看。推荐 nexT 主题，可以在 blog 路径下，输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 下载好之后，只需要在 _config.yml 配置文件中 theme 设置。再次利用上面的三个命令查看效果：再利用上面三个命令重新生成下，看看效果123hexo cleanhexo ghexo s 注：要让网站的配置文件的修改生效就必须利用 “hexo g”重新生成响应文件，而主题文件夹下的配置文件（“/theme/主题名称/_config.yml”）的修改只需要刷新网页即可看到效果 部署博客至GitHub在 GitHub 中建立自己的 public 库首先去 GitHub 注册自己的账号，然后登录，创建 New repository，如果你的账户名称是 ZhangSan，则需要创建一个名称为 “ZhangSan.github.io”的 public 库。此时我们需要给自己的电脑生成一个 ssh key 来连接 GitHub。在终端输入：1234cd ~git config --global user.name yournamegit config --global user.email yourmail@gmail.comssh-keygen -t rsa -C yourmail@gmail.com 连续按三次回车，设置密码为空。输入以下命令，复制里面的所有内容，再按 “Esc -&gt; :q” 回车，退出编辑界面。1vi .ssh/id_rsa.pub 在 GitHub 上点击右上角自己的头像 -&gt; Settings —&gt; SSH nd GPG keys —&gt; New SSH key，把刚刚复制的内容粘贴到 key 中，随便起个名字填入 title 并点击 Add SSH Key。 开始部署首先安装 hexo-deployer-git。在终端利用“cd”命令进入刚刚建立好的 blog 路径下，输入：1npm install hexo-deployer-git --save 然后打开 blog 文件夹下的 _config.yml 文件配置 deploy：1234deploy: type: git ------&gt; 直接填写 git repository: https://github.com/yourname/yourname.github.io.git -----&gt; Github 的仓库地址 brach: master 保存退出，在终端输入（d 即 deploy）：123hexo cleanhexo ghexo d 至此，成功之后便可以通过访问 “username.github.io” 来查看你的博客啦！ 参考文章本“教程”仅为博客搭建入门教程，也只是记录下自己第一次搭建博客的过程，大家可以根据自己的需求做进一步改进，如更换主题、删除文章等，详情参考官方文档 使用Hexo+Github一步步搭建属于自己的博客（基础） 搭建个人博客-hexo+github详细完整步骤 使用hexo+github搭建免费个人博客详细教程 hexo的next主题个性化教程:打造炫酷网站 PS：没想到第一次写个博客用了这么久，让某蛋久等了…以后这里应该也会写写这个某蛋的故事，希望将来不管谁看到的时候，都是满脸笑意]]></content>
      <categories>
        <category>技术篇</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
