<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中volatile关键字]]></title>
    <url>%2Farchives%2F34ac48e.html</url>
    <content type="text"><![CDATA[简介在Java内存模型中，有主内存和每个线程各自的工作内存。为了提高运行性能，一个线程会在自己的内存中拷贝一份成员变量的副本。而工作内存在线程之间是互相隔离的，彼此对其他线程不可见。线程对变量的所有操作都必须在工作内存中进行，修改结束后，变量副本需写会主内存。这样的内存机制变回导致同一个变量在某个时间点，在一个线程的内存中的值（如B）与另一个线程的内存中的值（如C），或是与主内存中的值（如A）不一致的情况。而volatile关键字正是为了避免这种情况，它会告诉JVM（Java虚拟机），被volatile修饰的变量不在其他线程的内存中保留拷贝，而是直接访问主内存的变量。 volatile关键字用法当一个变量声明为volatile时，就意味着这个变量被修改时其他所有使用到此变量的线程都立即能见到变化（称之为可见性），并可随时被其他线程修改。具体是在每次使用前都要先刷新，以保证别的线程中的修改已经反映到本线程工作内存中，因此可以保证执行时的一致性。举个栗子：12345678910111213public class StoppableTask extends Thread &#123; private volatile boolean pleaseStop; public void run() &#123; while (!pleaseStop) &#123; // do some stuff... &#125; &#125; public void tellMeToStop() &#123; pleaseStop = true; &#125; &#125; 假如pleaseStop变量没有用volatile声明，那么在线程执行run的时候检查的就是自己的变量副本，如果其他线程已经调用了tellMeToStop()方法修改了pleaseStop的值，当前线程就无法及时得知此消息。 volatile和sychronizedVolatile一般情况下不能代替sychronized，因为volatile不能保证操作的原子性！这里要注意，i++这样的操作并不是原子性的，它实际上也是由多个原子操作组成的。假如多个线程同时执行i++，volatile只能保证他们操作的i变量是同一块内存，但依然可能出现写入脏数据的情况。 Volatile是变量修饰符，而synchronized作用于一段代码或方法。举个栗子： 12345678910111213141516int i1;int geti1() &#123; return i1;&#125;volatile int i2;int geti2() &#123; return i2;&#125;int i3;synchronized int geti3() &#123; return i3;&#125;geti1() 在上面的代码中，3个get()方法都是用来取得当前线程中对于变量的值。对于geti1()方法，多个线程中有着多个i1变量的拷贝，并且这些值可以互不相同。因此有如下可能性：主内存中 i1 = 0，线程1中 i1 = 1，线程2中 i1 = 2……这里线程1和线程2中都改变了它们各自的i1的值，而这个改变还未及时传递给主内存和其他线程，就导致了这种情况的发生。 对于geti2()方法，无论哪个线程去调用，得到的都是主内存中的i2的值。因为i2是被volatile修饰的，它在所有线程中必须是同步的，任何线程改变了它的值的同时，其他线程便立即获得了相同的值。注意：volatile修饰的变量存取时比一般变量消耗的资源要多一点，因为线程有它自己的变量拷贝更为高效。 既然volatile关键字已经实现了线程间数据同步，为什么我们还要用synchronized呢？一方面，synchronized会获得并释放监视器。话句话说，如果两个线程使用了同一个对象锁，监视器能强制保证被synchronized修饰的代码块或方法同时只被一个线程所执行。另一方面，synchronized也同步内存。它在“主内存区域同步整个线程的内存。因此，上述geti3()方法在执行时做了如下几步： 线程请求获得监视this对象的对象锁（假设此时还未被锁，否则线程将等待直到锁释放后获得） 线程内存的数据被消除，从主内存区域中读入 代码块被执行 对于变量的任何改变现在可以安全地写到主内存区域中（上述代码中geti3()方法并没有修改变量值） 线程释放监视this对象的对象锁 总结一下就是：volatile关键字只是在线程内存和主内存间同步某个变量的值，而synchronized通过加锁和解锁，保证代码块被执行的安全，并同步所有变量的值。所以synchronized要比volatile消耗更多资源。 volatile与变量类型在Java中，volatile关键字一般用于声明简单类型变量，比如int、float、 boolean等数据类型。如果这些简单数据类型声明为volatile，对它们的操作就会成为原子性操作。但这也有一定的限制（如之前提到的i++操作），举个栗子： 1234567891011121314151617181920212223242526272829public class MyThread extends Thread &#123; public volatile int n = 0; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; n = n + 1; sleep(2); &#125; catch (Exception e) &#123; System.out.println("Some exceptions..."); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Thread threads[] = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new MyThread(); // 创建100个线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); // 运行刚刚的线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].join(); // 100个线程都执行完后继续 &#125; System.out.println("n = " + MyThread.n); &#125;&#125; 如果上述代码对变量n的操作是原子性的，那么最后输出的结果应该为 n = 1000。但是在执行上面积代码时，很多时侯输出的n都小于1000，这说明 n = n + 1 操作不是原子性的！原因是，如果声明为volatile的简单变量的当前值和该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作： n++; n = n + 1; 如果要想使这种情况成为原子性操作，就需要使用synchronized关键字。上述的代码可以改成如下的形式： 123456789101112131415161718192021222324252627282930313233public class MyThread extends Thread &#123; public volatile int n = 0; public static synchronized void addOne() &#123; n++; // 或 n = n + 1; &#125; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; addOne(); sleep(2); &#125; catch (Exception e) &#123; System.out.println("Some exceptions..."); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Thread threads[] = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new MyThread(); // 创建100个线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); // 运行刚刚的线程 &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].join(); // 100个线程都执行完后继续 &#125; System.out.println("n = " + MyThread.n); &#125;&#125; 上面的代码将简单的 n = n + 1 操作抽象成了 addOne() 方法，并使用synchronized关键字修饰，这时线程对于 n = n + 1 的操作便成为了原子性的。 在使用volatile关键字时一定要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作就都成为了原子性操作而保证线程安全，当变量的值受自身之前的值影响时，如 n = n + 1、n++ 等，volatile关键字便会失效；只有当变量的值和自身上一个值无关时，该变量的操作才是原子性的，如 n = m + 1 这个操作就是原子性的。 其他Volatile的另外一个作用是禁止指令的重排序优化。在一般情况下，Java执行语句的顺序可能会因为自动优化而修改，例如下面的例子，initialized的赋值有可能执行在doInitialize()语句之前，从而导致其他线程可能不会正确的等待初始化完成。 boolean initialized = false; 123// run in one threaddoInitialize();initialized = true; 1234// run in another threadwhile (!initialized) &#123; sleep();&#125; 如果将initialized变量用volatile关键字修饰，就能保证它的执行顺序不会被改变（似乎 Java SE 5之前的版本依然会有问题） ReferenceJava的volatile关键字的作用 Java中关键字volatile的作用]]></content>
      <categories>
        <category>学习与总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Hexo与GitHub搭建个人博客]]></title>
    <url>%2Farchives%2Ff23eadd3.html</url>
    <content type="text"><![CDATA[写在前面的废话很久以前就看到过许多漂亮的博客，尤其是在遇到技术问题百度一下的时候，总会点到一些技术大牛的个人博客里，看他们的解决方法和一些私人日志（偷笑）。每次看到漂亮的博客都觉的好羡慕，想着将来自己也搞这么个东西玩玩，于是就有了这个学来的“教程”。 了解 Hexo 和 GitHub 的朋友们，估计这篇小短文对你们也没什么帮助了，可以不用浪费时间啦~而对于普通小白，想要免费搭建一个可以让任何人都可以访问到的自己专属博客，可以继续往下看~ PS: 本教程以Mac OS作为参考，不同系统（Windows, Linux）具体安装工具方式可能不同，建议参考相关官网进行安装配置。 工具介绍HexoHexo （GitHub地址）是一个基于 Node.js 的静态博客程序，可以方便的生成静态网页托管在 Github 和 Heroku上。作者是来自台湾的@tommy351。官方介绍：12A fast, simple &amp; powerful blog framework, powered by Node.js.基于 Node.js 的快速、简洁但功能强大的博客框架。 Node.js使用 Hexo 需要依赖于 Node.js，在此做简单介绍，引用百度百科内容：123Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台，用来方便地搭建快速的易于扩展的网络应用.Node.js 借助事件驱动，非阻塞 I/O 模型变得轻量和高效， 非常适合运行在分布式设备的数据密集型的实时应用.Node.js 对 Google V8 引擎(应用于 Google Chrome 浏览器)进行了封装. Github我们用 Hexo 搭建好的博客要将网站托管在 Github 上，在此也简单介绍下。引自百度百科：123gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 准备工作安装 Node.jsNode.js 可以从官网根据不同系统下载安装。这里 Mac OS 推荐使用 Homebrew进行安装，省去了配置环境等麻烦，也易于卸载。直接在终端输入命令：1ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 安装 node.js，在终端输入：1sudo brew install node 此时可能需要输入电脑密码，输入完成后等待安装完成。再输入：1node -v 如果可以看到版本号，说明安装成功。 安装 Hexo安装 Hexo 极其简单，官网也只有一条命令：1npm install hexo-cli -g 等待安装完成，输入1hexo --versio 看到版本号说明安装成功。 安装 git同样的，git 也可以从官网下载安装，或者用 homebrew1brew install git 直接安装。（不过 Mac OS 好像是自带git的吧，或者只要安装了 xcode，git 就会自动安装）测试安装是否成功，在终端输入： 1git --version 看到版本号说明安装成功。 搭建博客准备工作完成，终于可以开始搭建我们自己的博客了。其实跟着Hexo官网的教程很快就可以自己搞定，但是如果懒得去可以继续往下看。 注意：以下所有的操作都在终端进行 选择路径 用 “cd” 命令进入想要建立博客的路径（文件夹）1cd 文件夹名称 初始化博客 比如我们建立的博客名字叫 blog，则终端输入命令：1hexo init blog 切换到刚刚的 blog 目录下，安装所有的依赖包：12cd blognpm install 到此，博客就算成功建立起来了，我们已经可以启动博客看看效果了。 启动博客 运行以下命令进行清理1hexo clean 运行以下命令生成所需要的静态页面及文件（g 即 generate）1hexo g 运行以下命令启动服务器（s 即 server）1hexo s 然后打开浏览器，输入地址 localhost:4000 即可看到效果 发表文章 比如我们想发表一篇名为“我的第一篇博客”的文章，在终端输入：1hexo new 我的第一篇博客 运行之后可以在 source/_posts 目录下生成“我的第一篇博客.md”文件，进入便可用 MarkDown 语言编写博客。 再利用上面三个命令重新生成下，看看效果123hexo cleanhexo ghexo s 配置博客 网站的设置大部分都在 _config.yml 文件中，详细配置可以查看官方文档，下面列出一些简单的常用配置： title -&gt; 网站标题subtitle -&gt; 网站副标题description -&gt; 网站描述author -&gt; 作者名字language -&gt; 网站使用的语言theme -&gt; 网站主题 注意：进行配置时，要在冒号后面加一个英文空格！ 关于主题和其他配置 同样的，许多好看的主题都在官网查看。推荐 nexT 主题，可以在 blog 路径下，输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 下载好之后，只需要在 _config.yml 配置文件中 theme 设置。再次利用上面的三个命令查看效果：再利用上面三个命令重新生成下，看看效果123hexo cleanhexo ghexo s 注：要让网站的配置文件的修改生效就必须利用 “hexo g”重新生成响应文件，而主题文件夹下的配置文件（“/theme/主题名称/_config.yml”）的修改只需要刷新网页即可看到效果 部署博客至GitHub在 GitHub 中建立自己的 public 库首先去 GitHub 注册自己的账号，然后登录，创建 New repository，如果你的账户名称是 ZhangSan，则需要创建一个名称为 “ZhangSan.github.io”的 public 库。此时我们需要给自己的电脑生成一个 ssh key 来连接 GitHub。在终端输入：1234cd ~git config --global user.name yournamegit config --global user.email yourmail@gmail.comssh-keygen -t rsa -C yourmail@gmail.com 连续按三次回车，设置密码为空。输入以下命令，复制里面的所有内容，再按 “Esc -&gt; :q” 回车，退出编辑界面。1vi .ssh/id_rsa.pub 在 GitHub 上点击右上角自己的头像 -&gt; Settings —&gt; SSH nd GPG keys —&gt; New SSH key，把刚刚复制的内容粘贴到 key 中，随便起个名字填入 title 并点击 Add SSH Key。 开始部署首先安装 hexo-deployer-git。在终端利用“cd”命令进入刚刚建立好的 blog 路径下，输入：1npm install hexo-deployer-git --save 然后打开 blog 文件夹下的 _config.yml 文件配置 deploy：1234deploy: type: git ------&gt; 直接填写 git repository: https://github.com/yourname/yourname.github.io.git -----&gt; Github 的仓库地址 brach: master 保存退出，在终端输入（d 即 deploy）：123hexo cleanhexo ghexo d 至此，成功之后便可以通过访问 “username.github.io” 来查看你的博客啦！ 参考文章本“教程”仅为博客搭建入门教程，也只是记录下自己第一次搭建博客的过程，大家可以根据自己的需求做进一步改进，如更换主题、删除文章等，详情参考官方文档 使用Hexo+Github一步步搭建属于自己的博客（基础） 搭建个人博客-hexo+github详细完整步骤 使用hexo+github搭建免费个人博客详细教程 hexo的next主题个性化教程:打造炫酷网站 PS：没想到第一次写个博客用了这么久，让某蛋久等了…以后这里应该也会写写这个某蛋的故事，希望将来不管谁看到的时候，都是满脸笑意]]></content>
      <categories>
        <category>技术篇</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
